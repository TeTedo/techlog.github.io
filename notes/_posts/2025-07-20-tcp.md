---
title: "TCP 통신 그리고 IP"
date: 2025-07-20
categories: [네트워크]
tags: [TCP, IP, 통신, 네트워크]
---

# TCP(Transmission Control Protocol)

- [1. TCP 개요](#1-tcp-개요)
- [2. 비트와 바이트, 네트워크에서의 단위](#2-비트와-바이트-네트워크에서의-단위)
- [3. TCP 헤더 구조와 각 필드 설명](#3-tcp-헤더-구조와-각-필드-설명)
- [4. TCP 헤더 구조 그림](#4-tcp-헤더-구조-그림)
- [5. TCP 연결 관리: 3-way/4-way Handshake](#5-tcp-연결-관리-3-way4-way-handshake)
- [6. 신뢰성, 흐름제어, 혼잡제어, 오류제어 (OSI 계층과의 관계)](#6-신뢰성-흐름제어-혼잡제어-오류제어-osi-계층과의-관계)
- [7. TCP 통신의 실제 동작 예시(Golang)](#7-tcp-통신의-실제-동작-예시golang)
- [8. TCP와 UDP 비교](#8-tcp와-udp-비교)
- [9. IP란 무엇인가? (구조, 대역, 할당, 실전)](#9-ip란-무엇인가-구조-대역-할당-실전)
- [10. 참고자료](#10-참고자료)

## 1. TCP 개요

- **TCP(Transmission Control Protocol)**는 인터넷에서 가장 널리 사용되는 전송 계층 프로토콜.
- 신뢰성 있는 데이터 전송, 순서 보장, 흐름제어, 혼잡제어, 오류제어 등 다양한 기능 제공.
- 연결 지향형(연결을 맺고 데이터를 주고받음), 스트림 기반(데이터를 바이트 단위로 연속 전송).

## 2. 비트와 바이트, 네트워크에서의 단위

- **비트(bit)**: 정보의 최소 단위. 0 또는 1의 값을 가짐.
  - 1비트 = 0 또는 1
- **바이트(byte)**: 8비트로 구성.
  - 1바이트 = 8비트
- **네트워크에서의 단위**

  - **Kbps, Mbps, Gbps**: 초당 전송 속도를 나타내는 단위.
    - 1Kbps = 1,000bps, 1Mbps = 1,000,000bps, 1Gbps = 1,000,000,000bps
  - **패킷(Packet)**: 네트워크에서 전송되는 데이터의 논리적 단위.
  - **세그먼트(Segment)**: TCP에서 사용하는 데이터 단위(헤더+데이터).
  - **프레임(Frame)**: 데이터링크 계층에서 사용하는 단위(이더넷 프레임 등).

- **TCP 헤더의 각 필드 크기**
  - 필드 크기는 비트 단위로 정의되며, 바이트 단위로 환산해 실제 메모리에서 처리됨.
  - 예시: 16비트 = 2바이트, 32비트 = 4바이트

## 3. TCP 헤더 구조와 각 필드 설명

TCP 패킷(세그먼트)은 헤더와 데이터로 구성된다.  
헤더는 최소 20바이트(옵션 미포함), 최대 60바이트(옵션 포함)까지 확장 가능.

| 필드명             | 바이트(비트) | 설명                                                |
| ------------------ | ------------ | --------------------------------------------------- |
| Source Port        | 2 (16)       | 송신측 포트 번호                                    |
| Destination Port   | 2 (16)       | 수신측 포트 번호                                    |
| Sequence Number    | 4 (32)       | 데이터의 순서(시작 바이트 번호)                     |
| Acknowledgment Num | 4 (32)       | 수신측이 다음에 받을 것으로 기대하는 바이트 번호    |
| Data Offset        | 0.5 (4)      | 헤더 길이(4바이트 단위)                             |
| Reserved           | 0.5 (4)      | 예약(미사용)                                        |
| Flags              | 1 (8)        | 제어 플래그(SYN, ACK, FIN, RST, PSH, URG, ECE, CWR) |
| Window Size        | 2 (16)       | 수신측 버퍼 크기(흐름제어)                          |
| Checksum           | 2 (16)       | 오류 검출용 체크섬                                  |
| Urgent Pointer     | 2 (16)       | 긴급 데이터 위치(URG 플래그 사용 시)                |
| Options + Padding  | 가변         | 옵션(윈도우 스케일, 타임스탬프 등)                  |

### 주요 플래그(Flags)

- **SYN**: 연결 설정
- **ACK**: 응답(확인)
- **FIN**: 연결 종료
- **RST**: 연결 재설정
- **PSH**: 즉시 전송
- **URG**: 긴급 데이터
- **ECE/CWR**: 혼잡제어 관련

---

## 4. TCP 헤더 구조 그림

```
  0      4      8     12     16     20     24     28     32
  +------+------+------+------+------+------+------+------+
  |   Source Port    | Destination Port               |
  +------------------+-------------------------------+
  |                Sequence Number                   |
  +--------------------------------------------------+
  |             Acknowledgment Number                |
  +--------------------------------------------------+
  | Data |Rese-|  Flags  |       Window Size         |
  |Offset|rved |         |                          |
  +------+------+--------+--------------------------+
  |     Checksum        |    Urgent Pointer         |
  +---------------------+--------------------------+
  |         Options (if any) and Padding            |
  +----------------------------------------------- -+
```

- 각 필드는 위 표와 동일하게 배치됨.
- Flags(제어 비트)는 8비트로, SYN/ACK/FIN 등 여러 플래그가 동시에 사용될 수 있음.

## 5. TCP 연결 관리: 3-way/4-way Handshake

### 3-way Handshake(연결 성립)

- **언제?** TCP 연결을 새로 맺을 때(클라이언트가 서버에 접속 요청할 때) 사용.
- **어떻게?**
  1. **SYN**: 클라이언트 → 서버 (연결 요청, 시퀀스 번호 포함)
  2. **SYN-ACK**: 서버 → 클라이언트 (연결 수락, 시퀀스+ACK 번호 포함)
  3. **ACK**: 클라이언트 → 서버 (연결 확정, ACK 번호 포함)
- **왜 필요한가?**
  - 양쪽 모두 연결 의사를 확인하고, 시퀀스 번호를 동기화하여 신뢰성 있는 데이터 전송을 준비하기 위함.

### 4-way Handshake(연결 종료)

- **언제?** TCP 연결을 정상적으로 종료할 때(한쪽 또는 양쪽 모두 통신을 끝내고 싶을 때) 사용.
- **어떻게?**
  1. **FIN**: 종료 요청(한쪽)
  2. **ACK**: 종료 요청 수신 확인
  3. **FIN**: 반대쪽 종료 요청
  4. **ACK**: 종료 확정
- **왜 필요한가?**
  - 양쪽 모두 데이터 전송이 끝났음을 확인하고, 안전하게 연결을 해제하기 위함.
  - 데이터 유실 없이 모든 패킷이 전송되었는지 보장.

---

## 6. 신뢰성, 흐름제어, 혼잡제어, 오류제어 (OSI 계층과의 관계)

### 신뢰성 보장

- **시퀀스/ACK 번호**: 데이터 순서 보장, 중복/손실 감지
- **재전송**: ACK 미수신 시 재전송
- **OSI 계층**: **전송 계층(4계층, Transport Layer)**
  - TCP가 제공하는 신뢰성 기능은 OSI 7계층 중 전송 계층에 해당.

### 흐름제어(Flow Control)

- **윈도우(Window Size)**: 수신측이 처리 가능한 데이터 양을 송신측에 알림
- **슬라이딩 윈도우**: 윈도우 크기만큼만 데이터 전송, ACK 수신 시 윈도우 이동
- **OSI 계층**: **전송 계층(4계층, Transport Layer)**
  - 송수신 간 데이터 흐름을 제어하는 기능은 전송 계층의 역할.

### 혼잡제어(Congestion Control)

- **Slow Start, Congestion Avoidance, Fast Retransmit/Recovery** 등 알고리즘으로 네트워크 혼잡 시 전송 속도 조절
- **OSI 계층**: **전송 계층(4계층, Transport Layer)**
  - 네트워크 전체의 혼잡 상황을 감지하고 제어하는 기능도 전송 계층에 포함.

### 오류제어

- **체크섬**: 데이터 손상 검출
- **재전송**: 오류 발생 시 재전송
- **OSI 계층**:
  - **전송 계층(4계층, Transport Layer)**: TCP의 체크섬, 재전송 등
  - **데이터링크 계층(2계층, Data Link Layer)**: 이더넷 프레임의 CRC 등
  - 즉, 오류제어는 여러 계층에서 수행되지만, TCP의 오류제어는 전송 계층에 해당.

---

## 7. TCP 통신의 실제 동작 예시(Golang)

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    conn, err := net.Dial("tcp", "example.com:80")
    if err != nil {
        panic(err)
    }
    defer conn.Close()
    fmt.Println("TCP 연결 성공:", conn.RemoteAddr())
}
```

- 내부적으로 3-way handshake로 연결을 맺고, 데이터 송수신 후 4-way handshake로 종료.

## 8. TCP와 UDP 비교

| 구분     | TCP                               | UDP                    |
| -------- | --------------------------------- | ---------------------- |
| 연결방식 | 연결 지향(3-way handshake)        | 비연결형               |
| 신뢰성   | 보장(순서, 재전송, 흐름/혼잡제어) | 보장하지 않음          |
| 속도     | 상대적으로 느림                   | 빠름                   |
| 용도     | 웹, 파일전송, 이메일 등           | 스트리밍, DNS, VoIP 등 |
| 헤더크기 | 20~60바이트                       | 8바이트                |

## 9. IP란 무엇인가? (구조, 대역, 할당, 실전)

### IP란?

- 네트워크에서 각 장치를 고유하게 식별하는 논리적 주소.
- IPv4(32비트, 4옥텟), IPv6(128비트, 8블록)로 구분.

### IPv4 구조

- 4바이트(32비트), 10진수 4개로 표기(예: 192.168.1.10)
- 네트워크/호스트 부분으로 나뉨(서브넷 마스크로 구분)
- 1옥텟 = 8비트 = 1바이트

### IPv4 대역

- **공인 IP**: 인터넷에서 고유하게 식별, ISP에서 할당
- **사설 IP**: 내부망에서만 사용
  - 10.0.0.0 ~ 10.255.255.255
  - 172.16.0.0 ~ 172.31.255.255
  - 192.168.0.0 ~ 192.168.255.255
- **특수 대역**: 루프백(127.0.0.0/8), 멀티캐스트(224.0.0.0/4) 등

### IPv6 구조

- 16바이트(128비트), 16진수 8블록(예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)
- 주소 고갈 문제 해결, 더 많은 장치 지원

### IP 할당 방식

- **정적 할당(Static IP)**: 관리자가 직접 지정, 서버/네트워크 장비에 사용
- **동적 할당(DHCP)**: DHCP 서버가 자동 할당, 임대(Lease) 개념
- **NAT**: 사설 IP를 공인 IP로 변환, 여러 장치가 하나의 공인 IP 사용

### 서브넷 마스크와 CIDR

- **서브넷 마스크**: 네트워크/호스트 구분(예: 255.255.255.0)
  - 255 = 8비트(11111111), 0 = 8비트(00000000)
  - 255.255.255.0 = 24비트(네트워크), 8비트(호스트)
- **CIDR(Classless Inter-Domain Routing, 클래스 없는 도메인 간 라우팅)**:
  - IP 주소와 서브넷 마스크를 슬래시(/)와 숫자로 표기하는 방식.
  - 예: 192.168.1.0/24 → 24비트가 네트워크 부분(255.255.255.0과 동일)
  - **의미**: IP 주소 공간을 더 유연하게 분할(서브넷팅)하고, 네트워크 낭비를 줄이기 위해 도입된 표기법.
  - **/24, /8 등 숫자의 의미**:
    - **슬래시 뒤 숫자**는 "앞에서부터 몇 비트가 네트워크 주소인지"를 의미하며,  
      **남은 비트**는 호스트 주소로 사용되어 "해당 네트워크에서 만들 수 있는 호스트(장치) 개수"를 결정합니다.
    - **계산법**:
      - 호스트 비트 수 = 32 - (슬래시 뒤 숫자)
      - 만들 수 있는 호스트 개수 = 2^(호스트 비트 수) - 2  
        (네트워크 주소와 브로드캐스트 주소를 제외)
    - **/24**: 앞에서부터 24비트가 네트워크 주소, 나머지(32-24=8비트)가 호스트 주소
      - 192.168.1.0/24 → 네트워크: 192.168.1, 호스트: 0~255
      - 만들 수 있는 호스트: 2^8 - 2 = 254개
    - **/8**: 앞에서부터 8비트가 네트워크 주소, 나머지(32-8=24비트)가 호스트 주소
      - 10.0.0.0/8 → 네트워크: 10, 호스트: 0.0.0~255.255.255
      - 만들 수 있는 호스트: 2^24 - 2 = 16,777,214개
    - **/28**: 앞에서부터 28비트가 네트워크 주소, 나머지(32-28=4비트)가 호스트 주소
      - 192.168.1.0/28 → 호스트: 0~15
      - 만들 수 있는 호스트: 2^4 - 2 = 14개
    - **/32**: 32비트 모두가 네트워크 주소(즉, 단일 IP만 지정, 호스트 없음)
  - 예시:
    - 32.163.1.0/24 → 32.163.1.0 ~ 32.163.1.255 (네트워크 24비트, 호스트 8비트)
    - 10.0.0.0/8 → 10.0.0.0 ~ 10.255.255.255 (네트워크 8비트, 호스트 24비트)
    - 192.168.1.0/28 → 192.168.1.0 ~ 192.168.1.15 (네트워크 28비트, 호스트 4비트)

## References

- https://youtu.be/6l7xP7AnB64?si=Ls7GPYc1M04mmBkL
- https://youtu.be/X73Jl2nsqiE?si=9e-ctyHrfozE1y1A
